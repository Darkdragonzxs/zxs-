<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Auto-click Play (iframe)</title>
  <style>
    :root {
      --bg: #0b0b0b;
      --panel: rgba(0,0,0,0.6);
      --accent: #28a0ff;
      --success: #2ecc71;
      --danger: #ff5c5c;
      --text: #e8eef6;
    }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--text); font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    #wrap { height:100vh; display:grid; grid-template-rows: auto 1fr; }
    header {
      padding:10px 14px;
      background: linear-gradient(90deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      display:flex; align-items:center; gap:12px;
      border-bottom:1px solid rgba(255,255,255,0.03);
    }
    header h1 { font-size:14px; margin:0; font-weight:600; letter-spacing:0.2px; }
    header .small { font-size:12px; color:rgba(232,238,246,0.7); font-weight:400; }
    main { position:relative; }
    iframe { width:100%; height:calc(100vh - 52px); border:0; display:block; }

    /* Status overlay */
    #status {
      position:fixed;
      right:14px;
      bottom:14px;
      background:var(--panel);
      color:var(--text);
      padding:10px 12px;
      border-radius:10px;
      box-shadow:0 8px 20px rgba(0,0,0,0.6);
      backdrop-filter: blur(6px);
      font-size:13px;
      z-index:99999;
      display:flex;
      gap:10px;
      align-items:center;
    }
    #status .dot { width:10px; height:10px; border-radius:50%; background:#666; box-shadow:0 0 6px rgba(0,0,0,0.6); }
    #status.success .dot { background: var(--success); box-shadow:0 6px 18px rgba(46,204,113,0.12); }
    #status.error .dot { background: var(--danger); box-shadow:0 6px 18px rgba(255,92,92,0.12); }
    #status .msg { min-width:170px; }
    #status button {
      background:transparent;
      border:1px solid rgba(255,255,255,0.08);
      color:var(--text);
      padding:6px 10px;
      border-radius:8px;
      cursor:pointer;
      font-size:13px;
    }
    #status button.primary {
      background:linear-gradient(180deg,var(--accent),#0187e6);
      border: none;
      color: white;
      box-shadow: 0 6px 18px rgba(0,0,0,0.45);
    }
    #note {
      position: fixed;
      left: 14px;
      bottom: 14px;
      color: rgba(232,238,246,0.8);
      font-size:12px;
      background: rgba(0,0,0,0.45);
      padding:8px 10px;
      border-radius:8px;
      z-index:99998;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <header>
      <h1>Auto-click Play (iframe)</h1>
      <div class="small">Will locate <code>button.svelte-19kto5k</code> inside the iframe and click it.</div>
    </header>

    <main>
      <!-- Change src if needed -->
      <iframe id="gameFrame" src="/cloudmoon/game/com.roblox.client/" title="Cloudmoon Game"></iframe>
    </main>
  </div>

  <div id="status" aria-live="polite">
    <div class="dot" id="status-dot"></div>
    <div class="msg" id="status-msg">Waiting for iframe...</div>
    <button id="try-now" title="Attempt click now">Try now</button>
    <button id="show-error" style="display:none;">Details</button>
  </div>

  <div id="note">Same-origin required. If this page and the iframe are different origins, the script cannot access the iframe DOM.</div>

  <script>
    (function () {
      const iframe = document.getElementById('gameFrame');
      const statusDot = document.getElementById('status-dot');
      const statusMsg = document.getElementById('status-msg');
      const tryNow = document.getElementById('try-now');
      const showErrorBtn = document.getElementById('show-error');

      let lastError = null;
      const selector = 'button.svelte-19kto5k';
      const MAX_WAIT = 20000; // ms to wait for button
      const POLL_INTERVAL = 250;

      const setStatus = (state, text) => {
        statusMsg.textContent = text;
        document.getElementById('status').classList.remove('success', 'error');
        if (state === 'ok') {
          document.getElementById('status').classList.add('success');
        } else if (state === 'error') {
          document.getElementById('status').classList.add('error');
        }
      };

      const tryClickButton = async () => {
        try {
          // Access iframe document (may throw if cross-origin)
          const doc = iframe.contentDocument || iframe.contentWindow.document;
          if (!doc) throw new Error('iframe document not accessible');

          // Try to find button immediately
          const el = doc.querySelector(selector);
          if (el) {
            // Preferred: native click
            try {
              el.click();
              setStatus('ok', 'Button clicked via .click()');
              return { method: 'click', element: el };
            } catch (eClick) {
              // fallback to dispatching MouseEvent at center
              const r = el.getBoundingClientRect();
              const centerX = Math.floor(r.left + r.width / 2);
              const centerY = Math.floor(r.top + r.height / 2);
              const evt = new MouseEvent('click', {
                view: iframe.contentWindow,
                bubbles: true,
                cancelable: true,
                clientX: centerX,
                clientY: centerY
              });
              el.dispatchEvent(evt);
              setStatus('ok', 'Button clicked via MouseEvent fallback');
              return { method: 'mouseEvent', element: el };
            }
          } else {
            throw new Error('Button not found in iframe DOM');
          }
        } catch (err) {
          lastError = err;
          console.error('Click attempt failed:', err);
          setStatus('error', String(err && err.message ? err.message : err));
          showErrorBtn.style.display = 'inline-block';
          return null;
        }
      };

      // Wait for iframe to be accessible & poll until the button appears (timeout)
      async function waitAndClick() {
        setStatus('error', 'Waiting for iframe to be accessible...');
        // wait for iframe load OR accessible
        await new Promise(resolve => {
          let resolved = false;
          const tryResolve = () => {
            try {
              // If same-origin and readyState present, resolve
              const doc = iframe.contentDocument || iframe.contentWindow && iframe.contentWindow.document;
              if (doc && (doc.readyState === 'interactive' || doc.readyState === 'complete')) {
                if (!resolved) { resolved = true; resolve(); }
              }
            } catch (e) {
              // cross-origin will throw here — we still wait for load event in that case
            }
          };
          iframe.addEventListener('load', () => {
            if (!resolved) { resolved = true; resolve(); }
          }, { once: true });

          // also poll a few times in case already accessible
          const checkInterval = setInterval(() => {
            tryResolve();
          }, 200);

          // stop polling after a short while if nothing happens — load event will still resolve eventually
          setTimeout(() => {
            clearInterval(checkInterval);
            if (!resolved) { resolved = true; resolve(); }
          }, 3000);
        });

        // Now poll for the button up to MAX_WAIT
        const start = Date.now();
        while (Date.now() - start < MAX_WAIT) {
          const result = await tryClickButton();
          if (result) return result;
          await new Promise(r => setTimeout(r, POLL_INTERVAL));
        }
        // final attempt & fail
        setStatus('error', 'Timed out waiting for button (increase MAX_WAIT if needed)');
        return null;
      }

      // Kick it off automatically
      waitAndClick().catch(e => {
        console.error('Unexpected error in waitAndClick:', e);
        setStatus('error', String(e && e.message ? e.message : e));
      });

      // Manual try now button
      tryNow.addEventListener('click', async () => {
        setStatus('error', 'Manual attempt...');
        await tryClickButton();
      });

      showErrorBtn.addEventListener('click', () => {
        if (!lastError) alert('No additional error info available.');
        else alert('Last error:\n' + (lastError.stack || lastError.message || String(lastError)));
      });

      // show a helpful note if cross-origin access is blocked
      window.addEventListener('error', (ev) => {
        // noop — console will show it; we keep user visible status via setStatus above
      });
    })();
  </script>
</body>
</html>
